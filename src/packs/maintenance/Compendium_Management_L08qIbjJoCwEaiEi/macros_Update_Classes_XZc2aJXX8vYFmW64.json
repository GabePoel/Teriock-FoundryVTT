{
  "name": "Update Classes",
  "type": "script",
  "_id": "XZc2aJXX8vYFmW64",
  "author": "IIjfAJm5Tf1B6G7t",
  "img": "systems/teriock/assets/rank.svg",
  "scope": "global",
  "command": "const classPack = game.teriock.packs.classes();\nconst classFolders = classPack.folders;\n\nconst progress = ui.notifications.info(`Pulling classes from wiki.`, {\n  progress: true,\n});\n\n/**\n * Processes a single rank item\n * @param {string} archetype - The archetype key\n * @param {string} className - The class key  \n * @param {Object} classObj - The class object\n * @param {number} rank - The rank number\n * @param {Object} classFolder - The class folder object\n * @returns {Promise<Object>} Promise that resolves with processing result\n */\nasync function processRank(archetype, className, classObj, rank, classFolder) {\n  const name = `Rank ${rank} ${classObj.name}`;\n\n  await classPack.getIndex();\n  let rankItem = classPack.index.find((e) => e.name === name);\n  \n  if (rankItem) {\n    rankItem = await foundry.utils.fromUuid(rankItem.uuid);\n  }\n\n  // Create new item\n  const itemData = {\n    name,\n    type: \"rank\",\n    folder: classFolder?.id,\n    system: {\n      archetype: archetype,\n      className: className,\n      classRank: rank,\n    },\n  };\n\n  try {\n    const TeriockItem = CONFIG.Item.documentClass;\n    if (!rankItem) {\n      rankItem = /** @type {TeriockRank} */ await TeriockItem.create(itemData, {\n        pack: \"teriock.classes\",\n      });\n    }\n    await rankItem.system.wikiPull({\n      notify: false,\n    });\n    return { name, success: true };\n  } catch (e) {\n    console.error(`Error creating or processing '${name}':`, e);\n    return { name, success: false, error: e.message };\n  }\n}\n\n/**\n * Processes all ranks for a single class in parallel\n * @param {string} archetype - The archetype key\n * @param {string} className - The class key\n * @param {Object} classObj - The class object\n * @param {Object} archetypeFolder - The archetype folder object\n * @returns {Promise<Object>} Promise that resolves with processing results\n */\nasync function processClass(archetype, className, classObj, archetypeFolder) {\n  // Find or create class folder\n  let classFolder = classFolders.getName(classObj.name);\n  if (!classFolder) {\n    try {\n      classFolder = await Folder.create(\n        {\n          name: classObj.name,\n          type: \"Item\",\n          folder: archetypeFolder?.id,\n        },\n        { pack: \"teriock.classes\" },\n      );\n    } catch (e) {\n      console.error(`Failed to create class folder '${classObj.name}':`, e);\n      return { className: classObj.name, success: false, error: e.message };\n    }\n  }\n\n  // Create promises for all ranks (1-5) in parallel\n  const rankPromises = [];\n  for (let r = 1; r < 6; r++) {\n    rankPromises.push(processRank(archetype, className, classObj, r, classFolder));\n  }\n\n  try {\n    const rankResults = await Promise.all(rankPromises);\n    return { \n      className: classObj.name, \n      success: true, \n      ranks: rankResults \n    };\n  } catch (e) {\n    console.error(`Error processing ranks for class '${classObj.name}':`, e);\n    return { className: classObj.name, success: false, error: e.message };\n  }\n}\n\n/**\n * Processes all classes for a single archetype in parallel\n * @param {string} archetype - The archetype key\n * @param {Object} archetypeObj - The archetype object\n * @returns {Promise<Object>} Promise that resolves with processing results\n */\nasync function processArchetype(archetype, archetypeObj) {\n  // Find or create archetype folder\n  let archetypeFolder = classFolders.getName(archetypeObj.name);\n  if (!archetypeFolder) {\n    try {\n      archetypeFolder = await Folder.create(\n        {\n          name: archetypeObj.name,\n          type: \"Item\",\n        },\n        { pack: \"teriock.classes\" },\n      );\n    } catch (e) {\n      console.error(`Failed to create archetype folder '${archetypeObj.name}':`, e);\n      return { archetype: archetypeObj.name, success: false, error: e.message };\n    }\n  }\n\n  const classes = archetypeObj.classes;\n  \n  // Create promises for all classes in parallel\n  const classPromises = Object.entries(classes).map(([className, classObj]) =>\n    processClass(archetype, className, classObj, archetypeFolder)\n  );\n\n  try {\n    const classResults = await Promise.all(classPromises);\n    return { \n      archetype: archetypeObj.name, \n      success: true, \n      classes: classResults \n    };\n  } catch (e) {\n    console.error(`Error processing classes for archetype '${archetypeObj.name}':`, e);\n    return { archetype: archetypeObj.name, success: false, error: e.message };\n  }\n}\n\n// Main processing logic\nconst totalOperations = 3 * 5 * 5; // 3 archetypes × 5 classes × 5 ranks = 75 operations\n\n// Filter valid archetypes and create processing promises\nconst validArchetypes = Object.entries(CONFIG.TERIOCK.rankOptions)\n  .filter(([archetype, archetypeObj]) => [\"Mage\", \"Semi\", \"Warrior\"].includes(archetypeObj.name));\n\nprogress.update({ \n  pct: 0.1, \n  message: `Processing ${validArchetypes.length} archetypes in parallel...` \n});\n\ntry {\n  // Process all archetypes in parallel\n  const archetypePromises = validArchetypes.map(([archetype, archetypeObj]) =>\n    processArchetype(archetype, archetypeObj)\n  );\n\n  const results = await Promise.all(archetypePromises);\n  \n  // Calculate total successful operations\n  let totalProcessed = 0;\n  const archetypeResults = [];\n  \n  for (const result of results) {\n    if (result.success) {\n      const successfulRanks = result.classes\n        .flatMap(c => c.ranks || [])\n        .filter(r => r.success);\n      totalProcessed += successfulRanks.length;\n      archetypeResults.push({\n        archetype: result.archetype,\n        ranksProcessed: successfulRanks.length\n      });\n    } else {\n      console.error(`Failed to process archetype ${result.archetype}:`, result.error);\n      archetypeResults.push({\n        archetype: result.archetype,\n        ranksProcessed: 0,\n        error: result.error\n      });\n    }\n  }\n\n  progress.update({ \n    pct: 1, \n    message: `Successfully processed ${totalProcessed} ranks across ${archetypeResults.length} archetypes.` \n  });\n\n  console.log(\"Archetype processing results:\", archetypeResults);\n\n} catch (error) {\n  progress.update({ \n    pct: 1, \n    message: `Error occurred during processing: ${error.message}` \n  });\n  console.error(\"Error processing classes:\", error);\n}",
  "folder": "L08qIbjJoCwEaiEi",
  "sort": 75000,
  "ownership": {
    "default": 0,
    "IIjfAJm5Tf1B6G7t": 3
  },
  "flags": {},
  "_stats": {
    "compendiumSource": null,
    "duplicateSource": null,
    "exportSource": null,
    "coreVersion": "13.345",
    "systemId": "teriock",
    "systemVersion": "0.1.0",
    "createdTime": 1753131250101,
    "modifiedTime": 1755752810661,
    "lastModifiedBy": "qf5JYGZKzM588nE6"
  },
  "_key": "!macros!XZc2aJXX8vYFmW64"
}
