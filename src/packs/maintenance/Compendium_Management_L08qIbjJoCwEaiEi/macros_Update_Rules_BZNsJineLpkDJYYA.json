{
  "name": "Update Rules",
  "type": "script",
  "_id": "BZNsJineLpkDJYYA",
  "author": "uxE8DDp7ujgsxtd2",
  "img": "icons/svg/book.svg",
  "scope": "global",
  "command": "const coreRulesPack = game.teriock.packs.rules();\n\nconst namespaceCategoryMap = {\n  Core: \"Core rules\",\n  Keyword: \"Keywords\",\n  Damage: \"Damage types\",\n  Drain: \"Drain types\",\n  Condition: \"Conditions\",\n  Property: \"Properties\",\n  Tradecraft: \"Tradecrafts\",\n};\n\n/**\n * Processes a single rules page\n * @param {Object} rulesPage - The rules page object from wiki\n * @param {string} namespace - The namespace for the rules\n * @param {Object} rulesJournal - The journal entry to add pages to\n * @returns {Promise<Object>} Promise that resolves with processing result\n */\nasync function processRulesPage(rulesPage, namespace, rulesJournal) {\n  const title = rulesPage.title;\n\n  // Extract rule name after the namespace prefix\n  const rulesName = title.slice(namespace.length + 1).trim();\n  if (!rulesName) {\n    console.warn(`Skipping page with empty rule name: \"${title}\"`);\n    return { title, rulesName: null, success: false, reason: \"Empty rule name\" };\n  }\n\n  try {\n    // Fetch and clean HTML\n    let rawHtml = await game.teriock.api.wiki.fetchWikiPageHTML(title, {\n      transformDice: true,\n      enrichText: true,\n      removeSubContainers: true,\n    });\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(rawHtml, \"text/html\");\n\n    // Remove unwanted elements\n    const selectorsToRemove = [\n      \"figure\",\n      \"#toc\",\n      \".mw-editsection-bracket\",\n      \".mw-editsection-visualeditor\",\n      \".citizen-editsection-icon\",\n      \".mw-ui-icon-wikimedia-edit\",\n      \".mw-editsection-divider\",\n      \".mw-file-description\",\n      \".mw-default-size\",\n    ];\n    selectorsToRemove.forEach((selector) => {\n      doc.querySelectorAll(selector).forEach((el) => el.remove());\n    });\n\n    const html = doc.body.innerHTML;\n\n    // Create or update journal page\n    let journalPage = rulesJournal.pages.getName(rulesName);\n\n    if (!journalPage) {\n      await rulesJournal.createEmbeddedDocuments(\"JournalEntryPage\", [\n        {\n          name: rulesName,\n          type: \"text\",\n          text: { content: html },\n        },\n      ]);\n      console.log(`Created: ${namespace}:${rulesName}`);\n      return { title, rulesName, success: true, action: \"created\" };\n    } else {\n      await journalPage.update({\n        text: { content: html },\n      });\n      console.log(`Updated: ${namespace}:${rulesName}`);\n      return { title, rulesName, success: true, action: \"updated\" };\n    }\n  } catch (error) {\n    console.error(`Error processing ${title}:`, error);\n    return { title, rulesName, success: false, error: error.message };\n  }\n}\n\n/**\n * Processes all rules for a single namespace\n * @param {string} namespace - The namespace to process\n * @param {string} category - The wiki category to fetch from\n * @returns {Promise<Object>} Promise that resolves with processing results\n */\nasync function processNamespace(namespace, category) {\n  console.log(`Processing namespace: ${namespace} (category: ${category})`);\n\n  try {\n    // Fetch all pages in the category\n    let allRulesPages =\n      await game.teriock.api.wiki.fetchCategoryMembers(category);\n    allRulesPages = allRulesPages.filter((page) =>\n      page.title.startsWith(`${namespace}:`),\n    );\n\n    // Attempt to load the journal from the pack\n    let rulesJournal = await foundry.utils.fromUuid(\n      coreRulesPack.index.getName(namespace)?.uuid ?? \"\",\n    );\n\n    // Create the journal if it's missing\n    if (!rulesJournal) {\n      console.warn(\n        `Journal for namespace '${namespace}' not found. Creating it...`,\n      );\n      rulesJournal = await JournalEntry.implementation.create(\n        { name: namespace },\n        { pack: \"teriock.rules\" },\n      );\n    }\n\n    // Process all rules pages in parallel\n    const pagePromises = allRulesPages.map(rulesPage =>\n      processRulesPage(rulesPage, namespace, rulesJournal)\n    );\n\n    const results = await Promise.all(pagePromises);\n    \n    const successfulPages = results.filter(r => r.success);\n    const failedPages = results.filter(r => !r.success);\n\n    console.log(`Namespace ${namespace}: ${successfulPages.length} successful, ${failedPages.length} failed`);\n    \n    if (failedPages.length > 0) {\n      console.warn(`Failed pages in ${namespace}:`, failedPages);\n    }\n\n    return {\n      namespace,\n      success: true,\n      totalPages: results.length,\n      successfulPages: successfulPages.length,\n      failedPages: failedPages.length,\n      results\n    };\n\n  } catch (error) {\n    console.error(`Error processing namespace ${namespace}:`, error);\n    return {\n      namespace,\n      success: false,\n      error: error.message\n    };\n  }\n}\n\n// Main processing logic - process all namespaces in parallel\ntry {\n  console.log(\"Starting parallel processing of all namespaces...\");\n  \n  const namespacePromises = Object.entries(namespaceCategoryMap).map(([namespace, category]) =>\n    processNamespace(namespace, category)\n  );\n\n  const namespaceResults = await Promise.all(namespacePromises);\n  \n  // Summary reporting\n  let totalSuccessful = 0;\n  let totalFailed = 0;\n  \n  for (const result of namespaceResults) {\n    if (result.success) {\n      totalSuccessful += result.successfulPages;\n      totalFailed += result.failedPages;\n      console.log(`✓ ${result.namespace}: ${result.successfulPages}/${result.totalPages} pages processed successfully`);\n    } else {\n      console.error(`✗ ${result.namespace}: Failed to process namespace - ${result.error}`);\n    }\n  }\n\n  console.log(`\\n=== SUMMARY ===`);\n  console.log(`Total successful pages: ${totalSuccessful}`);\n  console.log(`Total failed pages: ${totalFailed}`);\n  console.log(`Namespaces processed: ${namespaceResults.filter(r => r.success).length}/${namespaceResults.length}`);\n\n} catch (error) {\n  console.error(\"Error in main processing:\", error);\n}",
  "folder": "L08qIbjJoCwEaiEi",
  "sort": 250000,
  "ownership": {
    "default": 0,
    "uxE8DDp7ujgsxtd2": 3
  },
  "flags": {},
  "_stats": {
    "compendiumSource": null,
    "duplicateSource": null,
    "exportSource": null,
    "coreVersion": "13.345",
    "systemId": "teriock",
    "systemVersion": "0.1.0",
    "createdTime": 1754273233127,
    "modifiedTime": 1755753189443,
    "lastModifiedBy": "qf5JYGZKzM588nE6"
  },
  "_key": "!macros!BZNsJineLpkDJYYA"
}
