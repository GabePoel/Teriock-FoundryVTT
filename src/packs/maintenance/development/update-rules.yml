name: Update Rules
type: script
_id: BZNsJineLpkDJYYA
author: teriockBuilder00
img: icons/svg/book.svg
scope: global
command: |-
  const coreRulesPack = game.teriock.packs.rules;

  const namespaceCategoryMap = {
    Core: "Core rules",
    Keyword: "Keywords",
    Damage: "Damage types",
    Drain: "Drain types",
    Condition: "Conditions",
    Property: "Properties",
    Tradecraft: "Tradecrafts",
  };

  for (const [namespace, category] of Object.entries(namespaceCategoryMap)) {
    console.log(`Processing namespace: ${namespace} (category: ${category})`);

    // Fetch all pages in the category
    let allRulesPages = await teriock.helpers.wiki.fetchCategoryMembers(category);
    allRulesPages = allRulesPages.filter((page) =>
      page.title.startsWith(`${namespace}:`),
    );

    // Attempt to load the journal from the pack
    let rulesJournal = await fromUuid(
      coreRulesPack.index.getName(namespace)?.uuid ?? "",
    );

    // Create the journal if it's missing
    if (!rulesJournal) {
      console.warn(
        `Journal for namespace '${namespace}' not found. Creating it...`,
      );
      rulesJournal = await JournalEntry.implementation.create(
        { name: namespace },
        { pack: "teriock.rules" },
      );
    }

    for (const rulesPage of allRulesPages.filter(
      (p) => !(p.title.includes("Routine") && namespace === "Core"),
    )) {
      const title = rulesPage.title;

      // Extract rule name after the namespace prefix
      const rulesName = title.slice(namespace.length + 1).trim();
      if (!rulesName) {
        console.warn(`Skipping page with empty rule name: "${title}"`);
        continue;
      }

      // Fetch and clean HTML
      let rawHtml = await teriock.helpers.wiki.fetchWikiPageHTML(title, {
        transformDice: true,
        enrichText: true,
        removeSubContainers: true,
      });
      const parser = new DOMParser();
      const doc = parser.parseFromString(rawHtml, "text/html");

      // Remove unwanted elements
      const selectorsToRemove = [
        "figure",
        "#toc",
        ".mw-editsection-bracket",
        ".mw-editsection-visualeditor",
        ".citizen-editsection-icon",
        ".mw-ui-icon-wikimedia-edit",
        ".mw-editsection-divider",
        ".mw-file-description",
        ".mw-default-size",
      ];
      selectorsToRemove.forEach((selector) => {
        doc.querySelectorAll(selector).forEach((el) => el.remove());
      });
      doc.querySelectorAll("h1, h2, h3, h4, h5, h6").forEach((el) => {
        if (el.textContent.includes("Routine")) {
          el.remove();
        }
      });

      const html = doc.body.innerHTML;

      // Create or update a journal page
      let journalPage =
        /** @type {TeriockJournalEntryPage} */ rulesJournal.pages.getName(
          rulesName,
        );

      if (!journalPage) {
        journalPage = (
          await rulesJournal.createEmbeddedDocuments("JournalEntryPage", [
            {
              name: rulesName,
              type: "text",
              text: { content: html },
            },
          ])
        )[0];
        console.log(`Created: ${namespace}:${rulesName}`);
      } else {
        await journalPage.update({
          text: { content: html },
        });
        console.log(`Updated: ${namespace}:${rulesName}`);
      }

      let icon;
      let image;

      if (namespace === "Tradecraft") {
        icon = TERIOCK.options.document.fluency.icon;
        image = tm.path.getImage("tradecrafts", journalPage.name);
      } else if (namespace === "Core") {
        if (
          [
            "Movement",
            "Intelligence",
            "Perception",
            "Sneak",
            "Strength",
            "Presence",
          ].includes(journalPage.name)
        ) {
          icon = "star";
          let imageName = journalPage.name;
          if (imageName === "Presence") {
            imageName = "Unused Presence";
          }
          image = tm.path.getImage("attributes", imageName);
        }
      } else if (namespace === "Damage") {
        icon = "heart-crack";
        image = tm.path.getImage("damage-types", journalPage.name);
      } else if (namespace === "Drain") {
        icon = "droplet-slash";
        image = tm.path.getImage("drain-types", journalPage.name);
      } else if (namespace === "Condition") {
        icon = TERIOCK.options.document.condition.icon;
        image = tm.path.getImage("conditions", journalPage.name);
      }
      if (icon) {
        await journalPage.setFlag("teriock", "journalIcon", icon);
      } else {
        await journalPage.unsetFlag("teriock", "journalIcon");
      }
      if (image) {
        await journalPage.setFlag("teriock", "journalImage", image);
      } else {
        await journalPage.unsetFlag("teriock", "journalImage");
      }

      let pages = 0;
      const toUpdate = [];
      for (const page of rulesJournal.pages.contents.sort((a, b) =>
        a.name.localeCompare(b.name),
      )) {
        toUpdate.push({
          _id: page.id,
          sort: pages * 1000,
        });
        pages++;
      }
      await rulesJournal.updateEmbeddedDocuments("JournalEntryPage", toUpdate);
    }
  }
folder: L08qIbjJoCwEaiEi
ownership:
  default: 0
flags: {}
_stats:
  coreVersion: '13'
  systemId: teriock
  systemVersion: 0.1.0
  lastModifiedBy: teriockBuilder00
_key: '!macros!BZNsJineLpkDJYYA'
