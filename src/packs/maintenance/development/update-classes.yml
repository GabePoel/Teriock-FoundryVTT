name: Update Classes
type: script
_id: XZc2aJXX8vYFmW64
author: teriockBuilder00
img: systems/teriock/src/icons/documents/rank.svg
scope: global
command: >-
  const classPack = game.teriock.packs.classes;

  const classFolders = classPack.folders;


  const progress = ui.notifications.info(`Pulling classes from wiki.`, {
    progress: true,
  });


  const classJournalUuid =
    "Compendium.teriock.rules.JournalEntry.oVIOjeytcScUC2QJ";
  const classJournal =
    /** @type {TeriockJournalEntry} */ await fromUuid(classJournalUuid);

  const powers = /** @type {TeriockPower[]} */ await tm.utils.resolveDocuments(
    classPack.index.contents.filter((i) => i.type === "power"),
  );

  for (const power of powers) {
    await power.system.refreshFromCompendiumSource();
  }


  /**
   * Processes a single rank item
   * @param {Teriock.Parameters.Rank.RankArchetype} archetype - The archetype key
   * @param {Teriock.Parameters.Rank.RankClass} className - The class key
   * @param {object} classObj - The class object
   * @param {number} rank - The rank number
   * @param {TeriockFolder} classFolder - The class folder object
   * @returns {Promise<Object>} Promise that resolves with the processing result
   */
  async function processRank(archetype, className, classObj, rank, classFolder)
  {
    const name = `Rank ${rank} ${classObj.name}`;

    await classPack.getIndex();
    let rankItem = classPack.index.find((e) => e.name === name);

    if (rankItem) {
      rankItem = await fromUuid(rankItem.uuid);
    }

    // Create a new item
    const itemData = {
      name,
      type: "rank",
      folder: classFolder.id,
      system: {
        archetype: archetype,
        className: className,
        classRank: rank,
      },
    };

    try {
      const ItemClass = CONFIG.Item.documentClass;
      if (!rankItem) {
        rankItem = /** @type {TeriockRank} */ await ItemClass.create(itemData, {
          pack: "teriock.classes",
        });
      }
      await rankItem.system.wikiPull({
        notify: false,
      });
      return {
        name,
        success: true,
      };
    } catch (e) {
      console.error(`Error creating or processing '${name}':`, e);
      return {
        name,
        success: false,
        error: e.message,
      };
    }
  }


  /**
   * Processes all ranks for a single class in parallel
   * @param {Teriock.Parameters.Rank.RankArchetype} archetype - The archetype key
   * @param {Teriock.Parameters.Rank.RankClass} className - The class key
   * @param {TeriockRank} classObj - The class object
   * @param {TeriockFolder} archetypeFolder - The archetype folder object
   * @returns {Promise<Object>} Promise that resolves with processing results
   */
  async function processClass(archetype, className, classObj, archetypeFolder) {
    // Find or create a class folder
    let classFolder = classFolders.getName(classObj.name);
    if (!classFolder) {
      try {
        classFolder = await Folder.create(
          {
            name: classObj.name,
            type: "Item",
            folder: archetypeFolder?.id,
          },
          { pack: "teriock.classes" },
        );
      } catch (e) {
        console.error(`Failed to create class folder '${classObj.name}':`, e);
        return {
          className: classObj.name,
          success: false,
          error: e.message,
        };
      }
    }

    // Create promises for all ranks (1-5) in parallel
    const rankPromises = [];
    const rankNames = [];
    for (let r = 1; r < 6; r++) {
      rankNames.push(`Rank ${r} ${classObj.name}`);
      rankPromises.push(
        processRank(archetype, className, classObj, r, classFolder),
      );
    }

    const classPage =
      /** @type {TeriockJournalEntryPage} */ classJournal.pages.getName(
        classObj.name,
      );
    const rankUuids = rankNames
      .map((n) => classPack.index.find((e) => e.name === n)?.uuid)
      .filter((n) => n);
    const rankText = rankUuids.map((u) => `@Embed[${u}]`).join(`\n`);
    const archetypeText = `@Embed[${classPack.index.getName(tm.string.toTitleCase(archetype)).uuid}]`;
    const flaws = (await fromUuid(rankUuids[0]))?.system.flaws;
    const text = tm.utils.dedent(`
      ${TERIOCK.content.classes[className]}${flaws ? `\n<h2>Flaws</h2>\n${flaws}` : ""}
      <h2>Archetype</h2>
      <p>Every ${archetype} class gets the following power.</p>
      ${archetypeText}
      <h2>Ranks</h2>
      <p>For ranks 3, 4, and 5, choose one combat ability and one support ability to gain at each rank.</p>
      ${rankText}`);
    await classPage.update({ "text.content": text });
    await classPage.setFlag(
      "teriock",
      "journalImage",
      tm.path.getImage("classes", classObj.name),
    );
    await classPage.setFlag(
      "teriock",
      "journalIcon",
      TERIOCK.options.rank[archetype].classes[className].icon,
    );

    try {
      const rankResults = await Promise.all(rankPromises);
      return {
        className: classObj.name,
        success: true,
        ranks: rankResults,
      };
    } catch (e) {
      console.error(`Error processing ranks for class '${classObj.name}':`, e);
      return {
        className: classObj.name,
        success: false,
        error: e.message,
      };
    }
  }


  /**
   * Processes all classes for a single archetype in parallel
   * @param {string} archetype - The archetype key
   * @param {object} archetypeObj - The archetype object
   * @returns {Promise<Object>} Promise that resolves with processing results
   */
  async function processArchetype(archetype, archetypeObj) {
    // Find or create an archetype folder
    let archetypeFolder = classFolders.getName(archetypeObj.name);
    if (!archetypeFolder) {
      try {
        archetypeFolder = await Folder.create(
          {
            name: archetypeObj.name,
            type: "Item",
          },
          { pack: "teriock.classes" },
        );
      } catch (e) {
        console.error(
          `Failed to create archetype folder '${archetypeObj.name}':`,
          e,
        );
        return {
          archetype: archetypeObj.name,
          success: false,
          error: e.message,
        };
      }
    }

    const classes = archetypeObj.classes;

    // Create promises for all classes in parallel
    const classPromises = Object.entries(classes).map(([className, classObj]) =>
      processClass(archetype, className, classObj, archetypeFolder),
    );

    try {
      const classResults = await Promise.all(classPromises);
      return {
        archetype: archetypeObj.name,
        success: true,
        classes: classResults,
      };
    } catch (e) {
      console.error(
        `Error processing classes for archetype '${archetypeObj.name}':`,
        e,
      );
      return {
        archetype: archetypeObj.name,
        success: false,
        error: e.message,
      };
    }
  }


  // Filter valid archetypes and create processing promises

  const validArchetypes = Object.entries(TERIOCK.options.rank).filter(
    ([_archetype, archetypeObj]) =>
      ["Mage", "Semi", "Warrior"].includes(archetypeObj.name),
  );


  progress.update({
    pct: 0.1,
    message: `Processing ${validArchetypes.length} archetypes in parallel...`,
  });


  try {
    // Process all archetypes in parallel
    const archetypePromises = validArchetypes.map(([archetype, archetypeObj]) =>
      processArchetype(archetype, archetypeObj),
    );

    const results = await Promise.all(archetypePromises);

    // Calculate total successful operations
    let totalProcessed = 0;
    const archetypeResults = [];

    for (const result of results) {
      if (result.success) {
        const successfulRanks = result.classes
          .flatMap((c) => c.ranks || [])
          .filter((r) => r.success);
        totalProcessed += successfulRanks.length;
        archetypeResults.push({
          archetype: result.archetype,
          ranksProcessed: successfulRanks.length,
        });
      } else {
        console.error(
          `Failed to process archetype ${result.archetype}:`,
          result.error,
        );
        archetypeResults.push({
          archetype: result.archetype,
          ranksProcessed: 0,
          error: result.error,
        });
      }
    }

    progress.update({
      pct: 1,
      message: `Successfully processed ${totalProcessed} ranks across ${archetypeResults.length} archetypes.`,
    });

    console.log("Archetype processing results:", archetypeResults);
  } catch (error) {
    progress.update({
      pct: 1,
      message: `Error occurred during processing: ${error.message}`,
    });
    console.error("Error processing classes:", error);
  }
folder: L08qIbjJoCwEaiEi
ownership:
  default: 0
flags: {}
_stats:
  coreVersion: '13'
  systemId: teriock
  systemVersion: 0.1.0
  lastModifiedBy: teriockBuilder00
  compendiumSource: null
_key: '!macros!XZc2aJXX8vYFmW64'
