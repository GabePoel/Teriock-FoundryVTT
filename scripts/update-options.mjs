import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const outputDir = path.resolve(__dirname, '../module/helpers/constants/generated');
const manualDir = path.resolve(__dirname, '../module/helpers/constants/manual');

const camelCase = str =>
    str
        .toLowerCase()
        .replace(/[-\s]+(.)/g, (_, chr) => chr.toUpperCase());

const kebabCase = str =>
    str
        .replace(/\s+/g, '-')
        .replace(/([a-z])([A-Z])/g, '$1-$2')
        .toLowerCase();

const fileHeader = `// This file is auto-generated by scripts/update-options.mjs. Do not edit manually.\n\n`;

// Load manual overrides and removals
const loadManualOverrides = async (name) => {
    const file = `${kebabCase(name)}.mjs`;
    const fullPath = path.join(manualDir, file);

    if (fs.existsSync(fullPath)) {
        try {
            const mod = await import(`../module/helpers/constants/manual/${file}?t=${Date.now()}`);
            const override = mod[camelCase(name)] || {};
            const remove = mod.remove || [];
            console.log(`Loaded manual overrides for ${name}`);
            return { override, remove };
        } catch (err) {
            console.warn(`Failed to load manual overrides for ${name}:`, err.message);
        }
    }
    return { override: {}, remove: [] };
};

// Merge and write final object to file
const writeObjectToFile = async (titleList, exportVarName) => {
    const generated = Object.fromEntries(
        titleList.map(t => [camelCase(t), t])
    );

    const { override: manual, remove } = await loadManualOverrides(exportVarName);

    let merged = { ...generated, ...manual };

    // Apply removals
    if (remove.length > 0) {
        for (const key of remove.map(camelCase)) {
            if (merged[key]) {
                delete merged[key];
                console.log(`Removed "${key}" from ${exportVarName}`);
            }
        }
    }

    const output = `${fileHeader}export const ${camelCase(exportVarName)} = ${JSON.stringify(merged, null, 4)};\n`;
    const filePath = path.join(outputDir, `${kebabCase(exportVarName)}.mjs`);
    fs.writeFileSync(filePath, output, 'utf8');

    console.log(`Wrote ${Object.keys(merged).length} items to ${kebabCase(exportVarName)}.mjs`);
};

(async () => {
    const { fetchCategoryMembers } = await import('../module/helpers/wiki.mjs');

    try {
        // === PROPERTIES ===
        const subcategoriesToExtract = [
            'Magical properties',
            'Material properties',
            'Weapon fighting styles'
        ];
        const allPropertyMembers = await fetchCategoryMembers('Properties', {
            cmtype: 'page|subcat'
        });
        const directPropertyPages = allPropertyMembers
            .filter(m => !m.title.startsWith('Category:'))
            .map(m => m.title.replace(/^Property:/, ''));
        const subcategoryPages = new Set();
        for (const subcat of subcategoriesToExtract) {
            const members = await fetchCategoryMembers(subcat, { cmtype: 'page' });
            let pages = members
                .filter(m => !m.title.startsWith('Category:'))
                .map(m => m.title.replace(/^Property:/, ''));
            if (subcat === 'Weapon fighting styles') {
                pages = pages.map(p => p.replace(/ fighting style$/i, ''));
            }
            pages.forEach(p => subcategoryPages.add(p));
            await writeObjectToFile(pages, subcat);
        }

        const filteredProperties = directPropertyPages.filter(p => !subcategoryPages.has(p));
        await writeObjectToFile(filteredProperties, 'properties');

        // === EFFECTS ===
        const effectMembers = await fetchCategoryMembers('Effects', { cmtype: 'subcat' });
        const effectGroups = effectMembers
            .filter(m => m.title.startsWith('Category:'))
            .map(m => m.title.replace(/^Category:/, '').replace(/ effects$/i, ''));
        await writeObjectToFile(effectGroups, 'effects');

        // === EQUIPMENT ===
        const equipmentMembers = await fetchCategoryMembers('Equipment', {
            cmtype: 'page'
        });
        const equipmentPages = equipmentMembers
            .filter(m => !m.title.startsWith('Category:'))
            .map(m => m.title.replace(/^Equipment:/, ''));
        await writeObjectToFile(equipmentPages, 'equipment');

        // === CONDITIONS ===
        const conditionMembers = await fetchCategoryMembers('Conditions', {
            cmtype: 'page'
        });
        const conditionPages = conditionMembers
            .filter(m => !m.title.startsWith('Category:'))
            .map(m => m.title.replace(/^Condition:/, ''));
        await writeObjectToFile(conditionPages, 'conditions');

        // === ABILITIES ===
        const abilityMembers = await fetchCategoryMembers('Abilities', {
            cmtype: 'page'
        });
        const abilityPages = abilityMembers
            .filter(m => !m.title.startsWith('Category:'))
            .map(m => m.title.replace(/^Ability:/, ''));
        await writeObjectToFile(abilityPages, 'abilities');

        // === EQUIPMENT CLASSES ===
        const equipmentClassMembers = await fetchCategoryMembers('Equipment classes', {
            cmtype: 'page|subcat'
        });
        const equipmentClassPages = equipmentClassMembers
            .filter(m => !m.title.startsWith('Category:'))
            .map(m => m.title.replace(/^.*?:/, ''));
        const topSubcats = equipmentClassMembers
            .filter(m => m.title.startsWith('Category:'))
            .map(m => m.title.replace(/^Category:/, ''));
        let nestedSubcats = [];
        for (const subcat of topSubcats) {
            const nestedMembers = await fetchCategoryMembers(subcat, { cmtype: 'subcat' });
            const nested = nestedMembers
                .filter(m => m.title.startsWith('Category:'))
                .map(m => m.title.replace(/^Category:/, ''));
            nestedSubcats.push(...nested);
        }
        const allEquipmentItems = Array.from(new Set([
            ...equipmentClassPages,
            ...topSubcats,
            ...nestedSubcats
        ]));
        await writeObjectToFile(allEquipmentItems, 'equipmentClasses');

    } catch (err) {
        console.error('Error:', err);
    }
})();
